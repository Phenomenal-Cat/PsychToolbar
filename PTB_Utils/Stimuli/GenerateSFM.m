function [SFMTextureL, SFMTextureR] = GenerateSFM(Display, Stim, MaxDisparity, IPD)

%============================= GenerateSFM.m ==============================
% Generates animations of ambiguous and disparity-defined unambiguous 
% structure-from-motion (SFM) stimuli, based on input structure 'Stim'.  
% Returns animation frames as PsychToolbox textures, with each animation
% contained within a separate cell of the arrays for left and right eye
% images.
%
% IPUT ARGUMENTS:
%       Display                 Structure generated by DisplaySettings.m
%       Stim                    Structure containing stimulus parameters
%       MaxDisparity            Disparity in arcminutes of dots at the
%                               closest point of the object to the observer.
%       IPD                     Observer's interpupillary distance (metres)
%
% STIMULUS PARAMETERS:
%       Stim.Type:              0 = sphere, 1 = cylinder
%       Stim.Hemi:              0 = full object, 1 = half object
%       Stim.CVCC               1 = convex, 2 = concave
%       Stim.AngularVelocity:   angular velocity of rotation (°/s)
%       Stim.MaxDisparity       maximum disparity for catch period stimuli (arcmin)
%      	Stim.Veridical          0 = use max disparity, 1 = use geometrically correct disparity    
%     	Stim.Radius             radius of sphere or cylinder (°)
%     	Stim.Height             stimulus height (°)
%    	Stim.NoDots             total number of dots
%      	Stim.DotSize            dot size (°)
%      	Stim.DotColour          0 = black & white, 1 = single colour
%       Stim.DotColourRGB       RGB value to use for single colour dots
%     	Stim.NoFrames           = round((360/Stim.AngularVelocity)*Display.RefreshRate);   
%      	Stim.RadPerFrame        rotation between consecutive frames in radians
%      	Stim.Background         background colour  
%       Stim.DotType            0 = circular, 1 = square, 2 = antialiased
%       Stim.DotLifetime        Default: inf = do not replace. (Frames)
%       Stim.Tilt               axis tilt (CW/ACW) in degrees from vertical
%       Stim.Slant              axis slant (forward/ backward) in degrees from vertical
%       Stim.Shading            Matrix containing shading model
%       Stim.ShadingNoise       Amount of noise to add to shading signal (%)        
%       Stim.Filter             1 = apply Gaussian filter to dots. NB. This
%                               can drastically increase time taken to
%                               generate stimuli.  Consider alternative
%
% OUTPUT TEXTURES:
%       SFMTextureL{1}(Frame) = ambiguous stimulus
%       SFMTextureL{2}(Frame) = clockwise unambiguous stimulus (left eye)
%       SFMTextureL{3}(Frame) = anticlockwise unambiguous stimulus (left eye)
%
% FILE UPDATES:
% 03/12/2010 - Written by Aidan Murphy (apm909@bham.ac.uk)
% 17/11/2011 - Variable dot lifetime and shading/signal noise options added (APM)
%     ___  ______  __   __
%    /   ||  __  \|  \ |  \    APM SUBFUNCTIONS
%   / /| || |__/ /|   \|   \   Aidan P. Murphy - apm909@bham.ac.uk
%  / __  ||  ___/ | |\   |\ \  Binocular Vision Lab
% /_/  |_||_|     |_| \__| \_\ University of Birmingham
%==========================================================================
GenerateStartTime = GetSecs;

if nargin <= 2             	% If disparity input was not specified, 
    MaxDisparity = 0;     	% assume zero disparity
end
if MaxDisparity == 0     	% For zero disparity...
    Loops = 1;              % only generate an ambiguous stimulus
elseif MaxDisparity ~= 0  	% If a non-zero disparity was specified...
    Loops = 3;              % generate clockwise and anticlockwise unambiguous stimuli
end

if Stim.Type == 0
    Stim.Height = Stim.Radius*2;                                                        % Check aspect ratio for sphere stimuli
end
Stim.DotType = 2;                                                                       % Set type of dot to draw (2 = anti-aliased circles)
Stim.Filter = 0;                                                                    	% Set filtering of textures on or off
Stim.Window = [0,0,ceil((Stim.Radius*2)+Stim.DotSize), ceil(Stim.Height+Stim.DotSize)];	% Calculate the window into which stimuli will be drawn
Stim.Centre = Stim.Window([3, 4])/2;
Stim.backg = repmat(Stim.Background(1), [Stim.Window(4), Stim.Window(3)]);

%============= Add signal noise if requested
ShadeOffset = zeros(1,Stim.NoDots);
if isfield(Stim, 'ShadingNoise')
    ShadeOffset(1,rand(1,Stim.NoDots)<(Stim.ShadingNoise/100))=1;            	% Select Stim.ShadingNoise % of dots to add noise to
    ShadeOffset(1,ShadeOffset==1) = (rand(1,numel(find(ShadeOffset==1)))*2*pi);	% Displace dot shading by random proportion of 2pi radians
end

%============= Generate dot starting positions
Stim.Phi = 2*pi*rand(1,Stim.NoDots);                                    % generate uniformly distributed random azimuth angles in radians (range 0 - 2pi)
if Stim.Type == 0                                                       % if StimTyupe is Sphere...
    Stim.Theta = acos(1-(2*rand(1,Stim.NoDots)));                       % generate cosinusoidally distributed random zenith angles in radians (range 0 - pi)
elseif Stim.Type > 0                                                    % if StimTyupe is Cylinder or Half-Cylinder...
    Stim.ypos = (Stim.Height/2)*(1-(2*rand(1,Stim.NoDots)));            % generate uniformly distributed random dot heights (range 0 - cylinder height)
end
Backg = repmat(Stim.Background(1), [Stim.Window(4), Stim.Window(3), 4]);	% Create an empty stimulus background to draw to
Backg(:,:,4) = zeros(Stim.Window(4), Stim.Window(3));                       % Set alpha value of background to zero

%============= Generate dot lifetimes
if isfield(Stim, 'DotLifetime')
	if Stim.DotLifetime < inf
        StartFrameCount = randi(Stim.DotLifetime-1, [1, Stim.NoDots]); 	% Assign start count of lifetime for each dot
        EndAngle = Stim.Phi-((StartFrameCount-1)*Stim.RadPerFrame);    	% Calculate position to get dots back to their starting positions    
    else
        StartFrameCount = [];
    end
else
    StartFrameCount = [];
end

%============= Loop for each animation
for loop = 1:Loops
    if loop ==1
        Disparity = 0;                                      % On 1st loop render ambiguous stimulus
    elseif loop ==2
        Disparity = MaxDisparity;                        	% On 2nd loop render clockwise rotating unambiguous stimulus
    elseif loop ==3
        Disparity = -MaxDisparity;                       	% On 3rd loop render anticlockwise rotating unambiguous stimulus
    end
    phi = Stim.Phi;                                         % Reset dot positions to original starting position
    FrameCount = StartFrameCount;
    for Frame = 1:Stim.NoFrames
        SFMTextureL{loop}(Frame) = Screen('MakeTexture', Display.win, Backg);
        SFMTextureR{loop}(Frame) = Screen('MakeTexture', Display.win, Backg);

        %================ Check dot lifetimes
        if ~isempty(StartFrameCount)
            FrameCount = FrameCount+1;                                                                      % Keep frame count per dot
            if Frame <= Stim.NoFrames-Stim.DotLifetime
                phi(FrameCount> Stim.DotLifetime) = 2*pi*rand(1,numel(find(FrameCount> Stim.DotLifetime)));	% Assign new azimuth angle for expired dots
            elseif Frame > Stim.NoFrames-Stim.DotLifetime
                phi(FrameCount> Stim.DotLifetime) = EndAngle(FrameCount> Stim.DotLifetime);
            end
         	FrameCount(FrameCount> Stim.DotLifetime) = 1;                                                   % Reset frame count for expired dots
        end
        
        %================ Move dots for hemi-objects
        if Stim.Hemi == 1                                                       % For rotating hemisphere/hemicylinder...
            RearDots = find(mod(ceil(phi/pi),2));                               % for phi angles in the ranges pi:2pi and 3pi:4pi, etc...
            phi(RearDots) = phi(RearDots)+ repmat(pi, [1, numel(RearDots)]);	% dots leaving one side appear on the other side
        end
        
        %================ Convert polar coordinates to Euclidean coordinates
        if Stim.Type == 0                                   % For rotating sphere...
            xpos = Stim.Radius*sin(Stim.Theta).*cos(phi);  	% convert spherical coordinates to cartesian coordinates
            zpos = Stim.Radius*sin(Stim.Theta).*sin(phi);
            ypos = Stim.Radius*cos(Stim.Theta);
        elseif Stim.Type > 0                                % For rotating cylinder...
            xpos = Stim.Radius*cos(phi);                  	% convert cylinder coordinates to cartesian coordinates
            zpos = Stim.Radius*sin(phi);
            ypos = Stim.ypos;
        end
        
        %================ Add shading to dots
        if isfield(Stim, 'Shading')
            ShadePhi = phi + ShadeOffset;
            Dotcolour = nan(1, Stim.NoDots);
            if Stim.Type ==0
                ShadeTheta = Stim.Theta + ShadeOffset;
                ShadeXpos = ceil(Stim.Radius*sin(ShadeTheta).*cos(ShadePhi));
                ShadeZpos = ceil(Stim.Radius*cos(ShadeTheta));
                for n= 1:Stim.NoDots
                    ShadingZ = min([size(Stim.Shading{Stim.CVCC}, 1), ceil(Stim.Radius+ShadeZpos(n))]);
                    ShadingX = min([size(Stim.Shading{Stim.CVCC}, 2), ceil(Stim.Radius+ShadeXpos(n))]);
                    Dotcolour(n) = Stim.Shading{Stim.CVCC}(ShadingZ, ShadingX);
                    if Dotcolour(n)< (255-64)
                        Dotcolour(n) = Dotcolour(n)+64;
                    end
                end
            elseif Stim.Type > 0
                ShadeXpos = Stim.Radius*sin(ShadePhi);
                for n= 1:Stim.NoDots
                    ShadingX = min([size(Stim.Shading{Stim.CVCC}, 2), ceil(Stim.Radius+ShadeXpos(n))]);
                    Dotcolour(n) = Stim.Shading{Stim.CVCC}(1, ShadingX);
                    if Dotcolour(n)< (255-64)
                        Dotcolour(n) = Dotcolour(n)+64;
                    end
                end
            end
            Dotcolour = [Dotcolour; Dotcolour; Dotcolour];
        else
        
     	%================== Set dot colour
            if Stim.DotColour == 0                             	% For black and white dots...
                BWDots = mod(round(ypos),3);
                Dotcolour = [BWDots; BWDots; BWDots]*255;
            elseif Stim.DotColour == 1                         	% For single colour dots...
                Dotcolour = repmat(Stim.DotColourRGB', 1, Stim.NoDots);
            end
        end
        Dotcolour(4,:) = 255;                                   % Set alpha to full
        
        %================== Only plot dots on front face of hemi-cylinder
        if Stim.Hemi == 1 
            AllDots = [xpos; zpos; ypos; Dotcolour];                
            AllDots(:, AllDots(:,2) < 0) = [];
            xpos = AllDots(1, :); zpos = AllDots(2,:); Halfypos = AllDots(3,:); Dotcolour = AllDots(4:6,:);
        else
            Halfypos = ypos;
        end
        
        %================== Perform axis rotations
        if isfield(Stim, 'Tilt') || isfield(Stim, 'Slant')   
            if isfield(Stim, 'Tilt')                                       % Tilt axis [+ve = CW/ -ve = ACW)
                xposT = xpos*cosd(Stim.Tilt)-Halfypos*sind(Stim.Tilt);
                yposT = xpos*sind(Stim.Tilt)+Halfypos*cosd(Stim.Tilt);
            else 
                xposT = xpos;
                yposT = Halfypos;
            end
            zposT = zpos;
            if isfield(Stim, 'Slant')                                      % Slant axis [forward/ backward]
                yposS = yposT*cosd(Stim.Slant)-zposT*sind(Stim.Slant);       
                zposS = yposT*sind(Stim.Slant)+zposT*cosd(Stim.Slant);
            else
                yposS = yposT;
                zposS = zposT;
            end
            xposS = xposT;
            xpos = xposS; ypos = yposS;
        end
        

        %================== Calculate disparity for each dot
        if Disparity ~= 0
            if Stim.Veridical == 0
                maxDisp = (Disparity/60)*Display.Metres_per_deg;                   	% convert maximum disparity from arcmin to metres
                maxzpos = (maxDisp*Display.D)/(IPD-maxDisp);                      	% calculate maximum y-coordinate (cylinder depth) for given disparity
                zposm = zpos/Stim.Radius*maxzpos;                                	% scale all y-coordinates accordingly (metres)  
             	xposoffset = ((zposm*IPD)./ (zposm+repmat(Display.D, [1, numel(zposm)])) )/2*Display.Pixels_per_m;
            elseif Stim.Veridical == 1
                xposoffset = ( (zpos*IPD*Display.Pixels_per_m)./(zpos+repmat(Display.D*Display.Pixels_per_m, [1, numel(zpos)])) )/2;
            end
        elseif Disparity == 0
            xposoffset = 0;
        end
        xposL = xpos-xposoffset;
        xposR = xpos+xposoffset;
        
        
        %================== Draw dots to textures
        if Stim.Hemi == 0
            Screen('DrawDots', SFMTextureL{loop}(Frame), [xposL; ypos], Stim.DotSize, Dotcolour, Stim.Centre, Stim.DotType);
            Screen('DrawDots', SFMTextureR{loop}(Frame), [xposR; ypos], Stim.DotSize, Dotcolour, Stim.Centre, Stim.DotType);
        elseif Stim.Hemi == 1
            Screen('DrawDots', SFMTextureL{loop}(Frame), [xposL; Halfypos], Stim.DotSize, Dotcolour, Stim.Centre, Stim.DotType);
            Screen('DrawDots', SFMTextureR{loop}(Frame), [xposR; Halfypos], Stim.DotSize, Dotcolour, Stim.Centre, Stim.DotType);
        end
        
        %================= Apply Gaussian filtering to texture
        if Stim.Filter == 1
            kwidth = 3;
            stddev = kwidth / 3;                                                            % Build a filter kernel
            kernel = fspecial('gaussian', kwidth, stddev);      
            stype = 0;
            channels = 1;
            filter = Screen('OpenProxy', Display.win);                                    	% Create processing proxy
            Screen('HookFunction', filter, 'Enable', 'UserDefinedBlit');                 	% Enable it
          	shader = EXPCreateStatic2DConvolutionShader(kernel, channels, 4, stype,1);      % Build shader from kernel
            Screen('HookFunction', filter, 'PrependShader', 'UserDefinedBlit', '2DConvolutionOperator-1', shader);   % Attach our shader to proxies user defined processing chain:
            glFinish;
            ftex = 0;
            SFMTextureL{loop}(Frame) = Screen('TransformTexture', SFMTextureL{loop}(Frame), filter, ftex);
            SFMTextureR{loop}(Frame) = Screen('TransformTexture', SFMTextureR{loop}(Frame), filter, ftex);
        elseif Stim.Filter == 2
            blurop = CreateGLOperator(Display.win);
            Add2DConvolutionToGLOperator(blurop, fspecial('gaussian', 13, 5.5));
            SFMTextureL{loop}(Frame) = Screen('TransformTexture', SFMTextureL{loop}(Frame), blurop);
            SFMTextureR{loop}(Frame) = Screen('TransformTexture', SFMTextureR{loop}(Frame), blurop);
        end
        phi = phi+Stim.RadPerFrame;                                             % rotate dots around the vertical axis
    end
end

fprintf('\n%s.m executed in %.2f seconds\n', mfilename, GetSecs-GenerateStartTime);